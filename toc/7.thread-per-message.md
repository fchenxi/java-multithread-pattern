##概念##

上司把文件交给下属，指示“能帮我传真这份文件吗？”妻子对先生说“老公，帮忙倒一下垃圾喔”。
一个人将工作拜托给别人去做，是很常见的事情。拜托别人“这个工作交给你了”泥猴，就回来继续做自己的事情。

使用Thread-Per-Message Pattern时，“委托消息的一端”与“执行消息的一端”会是不同的线程。
也就像是委托消息的线程，对执行消息的线程说“这个工作交给你了”


##范例##

- Host.java

```
public class Host {
    private final Helper helper = new Helper();
    //在匿名内部类中，用到方法的参数或局部变量时，必须将变量声明称final。如果没有，会出现编译错误。
    public void request(final int count, final char c) {
        System.out.println("    request(" + count + ", " + c + ") BEGIN");
        new Thread() {
            public void run() {
                helper.handle(count, c);
            }
        }.start();
        System.out.println("    request(" + count + ", " + c + ") END");
    }
}

```

- Helper.java

```

public class Helper {
    public void handle(int count, char c) {
        System.out.println("        handle(" + count + ", " + c + ") BEGIN");
        for (int i = 0; i < count; i++) {
            slowly();
            System.out.print(c);
        }
        System.out.println("");
        System.out.println("        handle(" + count + ", " + c + ") END");
    }
    private void slowly() {
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
        }
    }
}

```

- Main.java

```
public class Main {
    public static void main(String[] args) {
        System.out.println("main BEGIN");
        Host host = new Host();
        host.request(10, 'A');
        host.request(20, 'B');
        host.request(30, 'C');
        System.out.println("main END");
    }
}

```

##Thread-Per-Message Pattern参与者##

- Client（委托人）参与者：Main类
- Host参与者：Host类
- Helper（帮助者）参与者：Helper类

Client--调用-->Host--使用-->Helper


##扩展思考##

- 提升响应性，降低延误时间

为了降低启动线程所需的时间，可使用Worker Pattern


- 适当在操作顺序无所谓时使用

handle的顺序并不一定是调用request方法的顺序。如果对操作顺序有要求，不适合使用Thread-Per-Message Pattern

- 不需要返回值的时候

例如通知事件的发生等等。
如果需要处理结果时，可使用Future Pattern

- 应用在服务器的制作

为了使服务器可以处理多数的请求，可以使用Thread-Per-Message Pattern。
客户端送达的请求，由主线程来接受。而实际处理该请求，则交给其他线程负责，服务器的主线程回到继续等待其他客户端请求的状态。


- 

##缺点##


##知识点##


##练习问题##