##概念##

小朋友总是把玩具洒落一地。晚上到了睡觉的时间时，妈妈会说“快把玩具收拾好，去睡觉吧”。
这时小朋友就停下来不玩了，开始收拾玩具。（这么听话吗？）

先从【作业中】进入【终止处理中】状态，在真正结束掉线程。这就是Two-phase Termination Pattern.

主要考虑的关键因素如下：

- 安全地结束（安全性）
- 一定会进行终止处理（生命性）
- 收到终止请求后，要尽快开始终止处理（响应性）


##范例程序##

- Countup Thread.java

shutdownRequest方法没有synchronized的必要。因为shutdownRequested标识
是一旦变成true就不会再变成false的latch（门闩），所以就算从多条线程同时调用也无所谓。
因为不会出现同时有线程要求设置为true，又有线程要求设置为false的race condition现象。


```
public class CountupThread extends Thread {
    // 计数器的值
    private long counter = 0;

    // 已经送出终止请求则为true
    private volatile boolean shutdownRequested = false;

    // 终止请求，下面两个缺一不可，具体原因见知识点
    public void shutdownRequest() {
        shutdownRequested = true;
        //使得线程就算在sleep或是wait的状态下，也能结束掉
        interrupt();
    }

    // 判断终止请求是否已经发出
    public boolean isShutdownRequested() {
        return shutdownRequested;
    }

    // 动作
    public final void run() {
        try {
            while (!isShutdownRequested()) {
                doWork();
            }
        } catch (InterruptedException e) {
        } finally {
            doShutdown();
        }
    }

    // 操作
    private void doWork() throws InterruptedException {
        counter++;
        System.out.println("doWork: counter = " + counter);
        Thread.sleep(500);
    }

    // 终止操作
    private void doShutdown() {
        System.out.println("doShutdown: counter = " + counter);
    }
}

```

- Main.java

Thread类的join方法，是用来等待到线程结束用的方法。在指定的线程结束前，不会从join方法中退出。
检查指定线程现在是否结束了，可以使用Thread.isAlive方法

```
public class Main {
    public static void main(String[] args) {
        System.out.println("main: BEGIN");
        try {
            // 启动线程
            CountupThread t = new CountupThread();
            t.start();

            // 稍微空出一段时间
            Thread.sleep(10000);

            // 对线程送出终止请求
            System.out.println("main: shutdownRequest");
            t.shutdownRequest();

            System.out.println("main: join");

            // 等待线程结束
            t.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("main: END");
    }
}

```


##Two-Phase Termination Pattern的所有参与者##

- TerminationRequest(送出终止请求的人)参与者：Main类
- Terminator（终止的人）参与者 ：CountupThread类


##知识点##

- 不可以使用Thread类的stop方法
	原因是stop方法会使实例丧失安全性的保障。使用stop方法时，线程会抛出
	java.lang.ThreadDeath异常而马上结束。即使该线程现在正在执行临界区间
	（例如synchronized方法的中间），也会马上结束。例如下面的例子

```
class Position{
	private int x;
	private int y;
	public synchronized void setXY(int newX,int newY){
		x = newX;
		y = newY;
	}

	...
}
```

因为说不定刚好在线程刚进行 x = newX;的指定操作，还没执行到y = newY;的时候，调用到stop方法。
于是，stop方法是不应该使用的。

- 只检查标识是不够周全的 shutdownRequested=true

shutdownRequest方法为什么需要调用interrupt方法。也就是说，为什么只把shutdownRequested标识设置为true是不够的呢？

理由很简单，当想要结束掉线程的时候，说不定线程现在正在sleep。如果线程正在sleep，就算将shutdownRequested标识设置为true，
线程也不会开始进行终止处理。或许过了sleep的时候后，就会开始执行终止处理，但这样程序的响应性就变差了。
所以如果使用interrupt方法，就应该把sleep中断掉。

线程或许也可能正在wait。如果线程正在wait，就算将shutdownRequested标识设置为true了，线程也不会退出等待区。
所以我们必须使用interrupt方法，要求线程“不要wait”了。


- 只测试中断状态也是不够的 interrupt()

“调用interrupt方法后，如果线程正在sleep或wait，则会抛出InterruptedException异常，就算没有抛出异常，线程也会变成中断状态。
既然如此，那又何必特地做一个新的shutdownRequested标识呢。只要catch住InterruptedException异常，并使用isInterrupted方法检查
中断状态，不就好了吗？”

提出这样的问题是很合理的。像范例程序，程序员如果可以掌握整个线程是，就不需要用到shutdownRequested标识了。
只要catch 住InterruptedException，并使用
isInterrupted方法，就可以正确地进行终止处理。

但是，如果线程会执行到任何一个会忽视InterruptedException的地方(而往往程序员很相信自己，觉得这样没什么，
肯定可以把所有抛出InterruptedException的地方都能正确地处理)，这样做就有待商榷了。
“会忽视InterruptedException的地方”，像下面就是

```
try{
	Thread.sleep(100);
}catch(InterruptedException e){
	//忽略 InterruptedException
}
```

当wait、sleep、join一抛出InterruptedException后，线程就不是中断状态了。
因为调用Thread.interrupted方法后，中断状态会被清除，所以必须检查终止请求。
也就是说，不使用shutdownRequested标识，而且上述的做法，可能无论怎么调用shutdownRequest方法，
记录还是被抹失了(程序员这时候就纳闷了，不应该了，是哪里处理问题吗？)。shutdownRequested标识是用来记录终止请求的标识。


- 进行繁重的处理前，先检查终止请求

为了使收到终止请求后，能尽快开始终止处理，故每当要开始繁重的处理前，
应该先检查shutdownRequested标识，或是调用isShutdownRequested方法。这样一来，
可使程序的响应性提高。



- NIO与多线程

J2SE1.4NIO 中实现了java.nio.channels.Channel接口的类群，设计时已将多线程考虑进去了。

例如，当线程对Channel阻挡住I/O时，其他线程可以把这个Channel给close掉。这是，这个阻挡I/O的线程，
会收到AsynchronousCloseException异常。
另外，线程对Channel阻挡住I/O时，其他线程也可以interrupt掉这个线程，这时，这个阻挡I/O的线程，会收到ClosedByInterruptException异常。

- 优雅终止的线程
 - 安全地终止（安全性）

即使收到终止请求，也不会马上结束线程。而是竖立表示收到终止请求的shutdownRequested标识。
以对象不会被破坏为前提，进行终止处理。
就像妈妈说了“去睡觉吧”，也不会慌忙地整理玩具，而把玩具弄坏一样。
 
 - 一定会进行终止处理（生命性）

当收到终止请求时，会中断可以中断的wait，前往终止处理。所以在shutdownRequest方法里，调用了interrupt方法。
另外，为了在抛出异常结束的时候，也会执行到终止处理，故使用了try...finally块。
就像不可以吧玩具散落一地，就跑去睡觉了的意思一样。

 
 - 送出终止请求后，要尽快进入终止处理（响应性）

 当收到终止请求后，会中断掉可以中断你的sleep，尽快前进到终止处理。于是在shutdownRequest方法中
 调用了interrupt方法。
 另外，在繁重的处理前，应该检查shutdownRequested标识。
 就像妈妈说了“快把玩具收拾好”后，应该尽快开始整理一样。
 像这样，优雅地结束掉线程，就像管教调皮的孩子一样。



 

##练习问题##