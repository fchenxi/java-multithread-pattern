##概念##

这是某个工厂的故事。在这里，工人要组装塑料玩具模型。
工作的委托人，会将很多塑料玩具模型盒子搬去工厂，堆放在桌子上。
工人必须组装收到的塑料玩具模型。工人首先会去那桌上堆放的模型盒子，并阅读盒内的说明书，
并将模型组装起来。做完工作的工人，就去拿下一个盒子来组合。如果没有模型盒子，就等待新的模型盒子送来......。

这就是Worker Thread Pattern

worker是“工人”的意思。Worker Thread Pattern中，工人线程（Worker Thread）会依次抓一件工作来处理。
当没有工作可作时，工人线程会停下来等待新的工作过来。

Woker Thread 也有人称为Background Thread(背景线程)。另外，也有人把视点放在管理工人线程的地方，
称之为Thread Pool.


##范例程序##

ClientThread类的线程，会对Channel类送出工作的请求（说是工作，在这里只是要求显示出请求者的名称与请求编号而已）
Channel类的实例管理着5个工人线程（Worker Thread），每个工人线程都等待收到请求。
当工作的请求来临时，工人线程会从抓一件请求来处理。处理结束后，就回到channel里，等待下一个工作。



- Main.java

```
public class Main {
    public static void main(String[] args) {
        Channel channel = new Channel(5);   // 工人线程的数量
        channel.startWorkers();
        new ClientThread("Alice", channel).start();
        new ClientThread("Bobby", channel).start();
        new ClientThread("Chris", channel).start();
    }
}

```
- ClientThread.java

用来送出工作请求

```
import java.util.Random;

public class ClientThread extends Thread {
    private final Channel channel;
    private static final Random random = new Random();
    public ClientThread(String name, Channel channel) {
        super(name);
        this.channel = channel;
    }
    public void run() {
        try {
            for (int i = 0; true; i++) {
                Request request = new Request(getName(), i);
                channel.putRequest(request);
                Thread.sleep(random.nextInt(1000));
            }
        } catch (InterruptedException e) {
        }
    }
}

```

- Request.java

用来表示工作请求

```
import java.util.Random;

public class Request {
    private final String name; // 委托者
    private final int number;  // 请求编号
    private static final Random random = new Random();
    public Request(String name, int number) {
        this.name = name;
        this.number = number;
    }
    public void execute() {
        System.out.println(Thread.currentThread().getName() + " executes " + this);
        try {
            Thread.sleep(random.nextInt(1000));
        } catch (InterruptedException e) {
        }
    }
    public String toString() {
        return "[ Request from " + name + " No." + number + " ]";
    }
}

```

- Channel.java

用来接收、传达工作请求，并保存工人线程



```
public class Channel {
    private static final int MAX_REQUEST = 100;
    private final Request[] requestQueue;//以 队列的方式存储请求
    private int tail;  // 下一个putRequest的地方
    private int head;  // 下一个takeRequest的地方
    private int count; // Request的数量

    private final WorkerThread[] threadPool;

    public Channel(int threads) {
        this.requestQueue = new Request[MAX_REQUEST];
        this.head = 0;
        this.tail = 0;
        this.count = 0;

        threadPool = new WorkerThread[threads];
        for (int i = 0; i < threadPool.length; i++) {
            threadPool[i] = new WorkerThread("Worker-" + i, this);
        }
    }
    public void startWorkers() {
        for (int i = 0; i < threadPool.length; i++) {
            threadPool[i].start();
        }
    }

    //在这里用到了Producer-Consumer Pattern和Guarded Suspension Pattern
    public synchronized void putRequest(Request request) {
        while (count >= requestQueue.length) {
            try {
                wait();
            } catch (InterruptedException e) {
            }
        }
        requestQueue[tail] = request;
        tail = (tail + 1) % requestQueue.length;
        count++;
        notifyAll();
    }
    public synchronized Request takeRequest() {
        while (count <= 0) {
            try {
                wait();
            } catch (InterruptedException e) {
            }
        }
        Request request = requestQueue[head];
        head = (head + 1) % requestQueue.length;
        count--;
        notifyAll();
        return request;
    }
}

```

- WorkerThread.java

工人线程可以执行工作,工人线程启动后，会永远不停的持续工作。

Thread-Per-Message Pattern中，是在每次执行工作的时候启动新的线程。
但在Worker Thread Pattern中，工人线程会不断地重复执行新工作，所以不需要启动新的线程。

WorkerThread的字段只有一个channel(Channel的实例)，用来获取工作请求让自己进行。
WorkerThread并不知道请求具体的内容（显示字符串的工作）。
WorkerThread只知道“Request类有execute这个方法”


```
public class WorkerThread extends Thread {
    private final Channel channel;
    public WorkerThread(String name, Channel channel) {
        super(name);
        this.channel = channel;
    }
    public void run() {
        while (true) {
            Request request = channel.takeRequest();
            request.execute();
        }
    }
}

```

- 执行结果

工人线程不会理会请求是谁推送的，只管执行收到的请求

```
Worker-0 executes [ Request from Alice No.0 ] Worker-0执行Alice的请求No.0
Worker-1 executes [ Request from Bobby No.0 ] Worker-1执行Bobby的请求No.0
Worker-2 executes [ Request from Chris No.0 ] Worker-2执行Chris的请求No.0
Worker-3 executes [ Request from Alice No.0 ] Worker-3执行Alice的请求No.0
Worker-4 executes [ Request from Bobby No.0 ] Worker-4执行Bobby的请求No.0
Worker-5 executes [ Request from Chris No.0 ] Worker-5执行Chris的请求No.0
Worker-6 executes [ Request from Bobby No.0 ] Worker-6执行Bobby的请求No.0
(CTRL+C结束程序)
```

##Worke工人r Thread Pattern的所有参与者##

- Client（委托人）参与者:ClientThread
- Channel（通路）参与者:Channel
- Worker（工人）参与者:WorkerThread
- Request（请求）参与者:Request



##缺点##


##知识点##


##练习问题##