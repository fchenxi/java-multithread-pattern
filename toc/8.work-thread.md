##概念##

这是某个工厂的故事。在这里，工人要组装塑料玩具模型。
工作的委托人，会将很多塑料玩具模型盒子搬去工厂，堆放在桌子上。
工人必须组装收到的塑料玩具模型。工人首先会去那桌上堆放的模型盒子，并阅读盒内的说明书，
并将模型组装起来。做完工作的工人，就去拿下一个盒子来组合。如果没有模型盒子，就等待新的模型盒子送来......。

这就是Worker Thread Pattern

worker是“工人”的意思。Worker Thread Pattern中，工人线程（Worker Thread）会依次抓一件工作来处理。
当没有工作可作时，工人线程会停下来等待新的工作过来。

Woker Thread 也有人称为Background Thread(背景线程)。另外，也有人把视点放在管理工人线程的地方，
称之为Thread Pool.


##范例程序##

ClientThread类的线程，会对Channel类送出工作的请求（说是工作，在这里只是要求显示出请求者的名称与请求编号而已）
Channel类的实例管理着5个工人线程（Worker Thread），每个工人线程都等待收到请求。
当工作的请求来临时，工人线程会从抓一件请求来处理。处理结束后，就回到channel里，等待下一个工作。



- Main.java

```
public class Main {
    public static void main(String[] args) {
        Channel channel = new Channel(5);   // 工人线程的数量
        channel.startWorkers();
        new ClientThread("Alice", channel).start();
        new ClientThread("Bobby", channel).start();
        new ClientThread("Chris", channel).start();
    }
}

```
- ClientThread.java

用来送出工作请求

```
import java.util.Random;

public class ClientThread extends Thread {
    private final Channel channel;
    private static final Random random = new Random();
    public ClientThread(String name, Channel channel) {
        super(name);
        this.channel = channel;
    }
    public void run() {
        try {
            for (int i = 0; true; i++) {
                Request request = new Request(getName(), i);
                channel.putRequest(request);
                Thread.sleep(random.nextInt(1000));
            }
        } catch (InterruptedException e) {
        }
    }
}

```

- Request.java

用来表示工作请求

```
import java.util.Random;

public class Request {
    private final String name; // 委托者
    private final int number;  // 请求编号
    private static final Random random = new Random();
    public Request(String name, int number) {
        this.name = name;
        this.number = number;
    }
    public void execute() {
        System.out.println(Thread.currentThread().getName() + " executes " + this);
        try {
            Thread.sleep(random.nextInt(1000));
        } catch (InterruptedException e) {
        }
    }
    public String toString() {
        return "[ Request from " + name + " No." + number + " ]";
    }
}

```

- Channel.java

用来接收、传达工作请求，并保存工人线程



```
public class Channel {
    private static final int MAX_REQUEST = 100;
    private final Request[] requestQueue;//以 队列的方式存储请求
    private int tail;  // 下一个putRequest的地方
    private int head;  // 下一个takeRequest的地方
    private int count; // Request的数量

    private final WorkerThread[] threadPool;

    public Channel(int threads) {
        this.requestQueue = new Request[MAX_REQUEST];
        this.head = 0;
        this.tail = 0;
        this.count = 0;

        threadPool = new WorkerThread[threads];
        for (int i = 0; i < threadPool.length; i++) {
            threadPool[i] = new WorkerThread("Worker-" + i, this);
        }
    }
    public void startWorkers() {
        for (int i = 0; i < threadPool.length; i++) {
            threadPool[i].start();
        }
    }

    //在这里用到了Producer-Consumer Pattern和Guarded Suspension Pattern
    public synchronized void putRequest(Request request) {
        while (count >= requestQueue.length) {
            try {
                wait();
            } catch (InterruptedException e) {
            }
        }
        requestQueue[tail] = request;
        tail = (tail + 1) % requestQueue.length;
        count++;
        notifyAll();
    }
    public synchronized Request takeRequest() {
        while (count <= 0) {
            try {
                wait();
            } catch (InterruptedException e) {
            }
        }
        Request request = requestQueue[head];
        head = (head + 1) % requestQueue.length;
        count--;
        notifyAll();
        return request;
    }
}

```

- WorkerThread.java

工人线程可以执行工作,工人线程启动后，会永远不停的持续工作。

Thread-Per-Message Pattern中，是在每次执行工作的时候启动新的线程。
但在Worker Thread Pattern中，工人线程会不断地重复执行新工作，所以不需要启动新的线程。

WorkerThread的字段只有一个channel(Channel的实例)，用来获取工作请求让自己进行。
WorkerThread并不知道请求具体的内容（显示字符串的工作）。
WorkerThread只知道“Request类有execute这个方法”


```
public class WorkerThread extends Thread {
    private final Channel channel;
    public WorkerThread(String name, Channel channel) {
        super(name);
        this.channel = channel;
    }
    public void run() {
        while (true) {
            Request request = channel.takeRequest();
            request.execute();
        }
    }
}

```

- 执行结果

工人线程不会理会请求是谁推送的，只管执行收到的请求

```
Worker-0 executes [ Request from Alice No.0 ] Worker-0执行Alice的请求No.0
Worker-1 executes [ Request from Bobby No.0 ] Worker-1执行Bobby的请求No.0
Worker-2 executes [ Request from Chris No.0 ] Worker-2执行Chris的请求No.0
Worker-3 executes [ Request from Alice No.0 ] Worker-3执行Alice的请求No.0
Worker-4 executes [ Request from Bobby No.0 ] Worker-4执行Bobby的请求No.0
Worker-5 executes [ Request from Chris No.0 ] Worker-5执行Chris的请求No.0
Worker-6 executes [ Request from Bobby No.0 ] Worker-6执行Bobby的请求No.0
(CTRL+C结束程序)
```

##Worke工人r Thread Pattern的所有参与者##

- Client（委托人）参与者:ClientThread
- Channel（通路）参与者:Channel
- Worker（工人）参与者:WorkerThread
- Request（请求）参与者:Request

##知识点##

- 启动线程是繁重的操作

如果可以把自己的工作交给别人做，自己就可以去做其他事情。
线程也一样，如果可以把工作交给其他线程，自己就可以继续前进到下一个工作。
这就是Thread-Per-Message Pattern的主题。
可是，启动线程是很花费时间的工作。所以，Worker Thread将重复使用线程、资源再利用也作为主题之一。

- 控制承载量，Worker Thread还有一个主题。就是承载量的控制
 - worker参与者的数量：
最先从某个一定量的Worker参与者开始；
当工作量增加时，增加Worker参与者；
不过增加太多会用完内存，所以到达某个上限要停止增加；
相反地，工作减少时，就结束掉Worker参与者

 - Request参与者的数量，也是Channel参与者中存放的Request的容量：
增加Channel参与者可存放的Request参与者数，可缓冲client参与者与Worker参与者的处理速度差。
可是，如果存储太多Request，也会占用大量的内存资源。
所以又陷入了容量与资源之间鱼与熊掌的关系。这个部分也是Producer-Consumer Pattern探讨过的。


- invocation启动方法与execution执行方法的分离
 - 提高响应性：即使execution花时间，invocation可以继续自己前进。
 - 控制实行顺序：execute的顺序可以与invoke的次序无关
 - 可取消和可重复执行
 - 分散处理的第一步


普通的调用方法操作，“启动方法”和“执行方法”是连续进行的。当方法一调用，就会马上继续执行。
普通的调用方法操作中，启动与执行时密不可分的。

但Worker Thread Pattern与Thread-Per-Message Pattern中，我们刻意将方法的启动与执行分开。
具体可以参考[设计模式之Command](http://www.jdon.com/designpatterns/command.htm)


- Runnable接口的意义

java.lang.Runnable接口，常常用来作为Worker Thread Paternity的Request参与者。
Runnable对象，可以作为方法的自变量传递、送到队列里、通过网络传递、甚至存进文件李。
而这样一个Runnable对象可以经过 多次传来传去，最后传到某台计算机的某条线程上，才真正交付执行。

这时，Runnable接口就可以看作是GoFramework的Command Pattern中的Command参与者。

- 多态的Request参与者

执行工作时所需要的信息，都定义在Request参与者里。所以即使建立出多态的Request参与者，
增加工作的种类，Channel参与者与Worker参与者都不需要修改。
即使增加工作的种类，Worker参与者都只是调用Request参与者的execute方法而已。

- 只有一条Worker参与者

如果只有一条工人线程的话，工人线程处理的范围就变成单线程，而可以省略共享互斥的必要了。

 
##相关知识##

- Swing 的Event-Dispatching Thread




##练习问题##