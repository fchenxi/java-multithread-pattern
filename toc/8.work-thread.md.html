<!doctype html public '-//W3C//DTD HTML 4.0 Transitional //EN'>
<html>
<head>
<title>8.work-thread</title>
<meta charset='UTF-8' />
<meta name='generator' content='EverEdit' />
<link href='E:\EverEdit\mode\markdown\default.css' rel='stylesheet'></link>
<link href='E:\EverEdit\mode\markdown\prettify.css' rel='stylesheet'></link>
<script type='text/javascript' src='E:\EverEdit\mode\markdown\prettify.js'></script>
<script type='text/javascript' src='E:\EverEdit\mode\markdown\jquery-1.10.2.min.js'></script>
<script type='text/javascript' src='E:\EverEdit\mode\markdown\toc.js'></script>
</head>
<body>
<div id='generated-toc'></div>
<h2>概念</h2>

<p>这是某个工厂的故事。在这里，工人要组装塑料玩具模型。
工作的委托人，会将很多塑料玩具模型盒子搬去工厂，堆放在桌子上。
工人必须组装收到的塑料玩具模型。工人首先会去那桌上堆放的模型盒子，并阅读盒内的说明书，
并将模型组装起来。做完工作的工人，就去拿下一个盒子来组合。如果没有模型盒子，就等待新的模型盒子送来......。</p>

<p>这就是Worker Thread Pattern</p>

<p>worker是“工人”的意思。Worker Thread Pattern中，工人线程（Worker Thread）会依次抓一件工作来处理。
当没有工作可作时，工人线程会停下来等待新的工作过来。</p>

<p>Woker Thread 也有人称为Background Thread(背景线程)。另外，也有人把视点放在管理工人线程的地方，
称之为Thread Pool.</p>

<h2>范例程序</h2>

<p>ClientThread类的线程，会对Channel类送出工作的请求（说是工作，在这里只是要求显示出请求者的名称与请求编号而已）
Channel类的实例管理着5个工人线程（Worker Thread），每个工人线程都等待收到请求。
当工作的请求来临时，工人线程会从抓一件请求来处理。处理结束后，就回到channel里，等待下一个工作。</p>

<ul>
<li>Main.java</li>
</ul>

<pre><code>public class Main {
    public static void main(String[] args) {
        Channel channel = new Channel(5);   // 工人线程的数量
        channel.startWorkers();
        new ClientThread("Alice", channel).start();
        new ClientThread("Bobby", channel).start();
        new ClientThread("Chris", channel).start();
    }
}
</code></pre>

<ul>
<li>ClientThread.java</li>
</ul>

<p>用来送出工作请求</p>

<pre><code>import java.util.Random;

public class ClientThread extends Thread {
    private final Channel channel;
    private static final Random random = new Random();
    public ClientThread(String name, Channel channel) {
        super(name);
        this.channel = channel;
    }
    public void run() {
        try {
            for (int i = 0; true; i++) {
                Request request = new Request(getName(), i);
                channel.putRequest(request);
                Thread.sleep(random.nextInt(1000));
            }
        } catch (InterruptedException e) {
        }
    }
}
</code></pre>

<ul>
<li>Request.java</li>
</ul>

<p>用来表示工作请求</p>

<pre><code>import java.util.Random;

public class Request {
    private final String name; // 委托者
    private final int number;  // 请求编号
    private static final Random random = new Random();
    public Request(String name, int number) {
        this.name = name;
        this.number = number;
    }
    public void execute() {
        System.out.println(Thread.currentThread().getName() + " executes " + this);
        try {
            Thread.sleep(random.nextInt(1000));
        } catch (InterruptedException e) {
        }
    }
    public String toString() {
        return "[ Request from " + name + " No." + number + " ]";
    }
}
</code></pre>

<ul>
<li>Channel.java</li>
</ul>

<p>用来接收、传达工作请求，并保存工人线程</p>

<pre><code>public class Channel {
    private static final int MAX_REQUEST = 100;
    private final Request[] requestQueue;//以 队列的方式存储请求
    private int tail;  // 下一个putRequest的地方
    private int head;  // 下一个takeRequest的地方
    private int count; // Request的数量

    private final WorkerThread[] threadPool;

    public Channel(int threads) {
        this.requestQueue = new Request[MAX_REQUEST];
        this.head = 0;
        this.tail = 0;
        this.count = 0;

        threadPool = new WorkerThread[threads];
        for (int i = 0; i &lt; threadPool.length; i++) {
            threadPool[i] = new WorkerThread("Worker-" + i, this);
        }
    }
    public void startWorkers() {
        for (int i = 0; i &lt; threadPool.length; i++) {
            threadPool[i].start();
        }
    }

    //在这里用到了Producer-Consumer Pattern和Guarded Suspension Pattern
    public synchronized void putRequest(Request request) {
        while (count &gt;= requestQueue.length) {
            try {
                wait();
            } catch (InterruptedException e) {
            }
        }
        requestQueue[tail] = request;
        tail = (tail + 1) % requestQueue.length;
        count++;
        notifyAll();
    }
    public synchronized Request takeRequest() {
        while (count &lt;= 0) {
            try {
                wait();
            } catch (InterruptedException e) {
            }
        }
        Request request = requestQueue[head];
        head = (head + 1) % requestQueue.length;
        count--;
        notifyAll();
        return request;
    }
}
</code></pre>

<ul>
<li>WorkerThread.java</li>
</ul>

<p>工人线程可以执行工作,工人线程启动后，会永远不停的持续工作。</p>

<p>Thread-Per-Message Pattern中，是在每次执行工作的时候启动新的线程。
但在Worker Thread Pattern中，工人线程会不断地重复执行新工作，所以不需要启动新的线程。</p>

<p>WorkerThread的字段只有一个channel(Channel的实例)，用来获取工作请求让自己进行。
WorkerThread并不知道请求具体的内容（显示字符串的工作）。
WorkerThread只知道“Request类有execute这个方法”</p>

<pre><code>public class WorkerThread extends Thread {
    private final Channel channel;
    public WorkerThread(String name, Channel channel) {
        super(name);
        this.channel = channel;
    }
    public void run() {
        while (true) {
            Request request = channel.takeRequest();
            request.execute();
        }
    }
}
</code></pre>

<ul>
<li>执行结果</li>
</ul>

<p>工人线程不会理会请求是谁推送的，只管执行收到的请求</p>

<pre><code>Worker-0 executes [ Request from Alice No.0 ] Worker-0执行Alice的请求No.0
Worker-1 executes [ Request from Bobby No.0 ] Worker-1执行Bobby的请求No.0
Worker-2 executes [ Request from Chris No.0 ] Worker-2执行Chris的请求No.0
Worker-3 executes [ Request from Alice No.0 ] Worker-3执行Alice的请求No.0
Worker-4 executes [ Request from Bobby No.0 ] Worker-4执行Bobby的请求No.0
Worker-5 executes [ Request from Chris No.0 ] Worker-5执行Chris的请求No.0
Worker-6 executes [ Request from Bobby No.0 ] Worker-6执行Bobby的请求No.0
(CTRL+C结束程序)</code></pre>

<h2>Worke工人r Thread Pattern的所有参与者</h2>

<ul>
<li>Client（委托人）参与者:ClientThread</li>
<li>Channel（通路）参与者:Channel</li>
<li>Worker（工人）参与者:WorkerThread</li>
<li>Request（请求）参与者:Request</li>
</ul>

<h2>知识点</h2>

<ul>
<li>启动线程是繁重的操作</li>
</ul>

<p>如果可以把自己的工作交给别人做，自己就可以去做其他事情。
线程也一样，如果可以把工作交给其他线程，自己就可以继续前进到下一个工作。
这就是Thread-Per-Message Pattern的主题。
可是，启动线程是很花费时间的工作。所以，Worker Thread将重复使用线程、资源再利用也作为主题之一。</p>

<ul>
<li><p>控制承载量，Worker Thread还有一个主题。就是承载量的控制</p>

<ul><li><p>worker参与者的数量：
最先从某个一定量的Worker参与者开始；
当工作量增加时，增加Worker参与者；
不过增加太多会用完内存，所以到达某个上限要停止增加；
相反地，工作减少时，就结束掉Worker参与者</p></li>
<li><p>Request参与者的数量，也是Channel参与者中存放的Request的容量：
增加Channel参与者可存放的Request参与者数，可缓冲client参与者与Worker参与者的处理速度差。
可是，如果存储太多Request，也会占用大量的内存资源。
所以又陷入了容量与资源之间鱼与熊掌的关系。这个部分也是Producer-Consumer Pattern探讨过的。</p></li></ul></li>
<li><p>invocation启动方法与execution执行方法的分离</p>

<ul><li>提高响应性：即使execution花时间，invocation可以继续自己前进。</li>
<li>控制实行顺序：execute的顺序可以与invoke的次序无关</li>
<li>可取消和可重复执行</li>
<li>分散处理的第一步</li></ul></li>
</ul>

<p>普通的调用方法操作，“启动方法”和“执行方法”是连续进行的。当方法一调用，就会马上继续执行。
普通的调用方法操作中，启动与执行时密不可分的。</p>

<p>但Worker Thread Pattern与Thread-Per-Message Pattern中，我们刻意将方法的启动与执行分开。
具体可以参考<a href="http://www.jdon.com/designpatterns/command.htm">设计模式之Command</a></p>

<ul>
<li>Runnable接口的意义</li>
</ul>

<p>java.lang.Runnable接口，常常用来作为Worker Thread Paternity的Request参与者。
Runnable对象，可以作为方法的自变量传递、送到队列里、通过网络传递、甚至存进文件李。
而这样一个Runnable对象可以经过 多次传来传去，最后传到某台计算机的某条线程上，才真正交付执行。</p>

<p>这时，Runnable接口就可以看作是GoFramework的Command Pattern中的Command参与者。</p>

<ul>
<li>多态的Request参与者</li>
</ul>

<p>执行工作时所需要的信息，都定义在Request参与者里。所以即使建立出多态的Request参与者，
增加工作的种类，Channel参与者与Worker参与者都不需要修改。
即使增加工作的种类，Worker参与者都只是调用Request参与者的execute方法而已。</p>

<ul>
<li>只有一条Worker参与者</li>
</ul>

<p>如果只有一条工人线程的话，工人线程处理的范围就变成单线程，而可以省略共享互斥的必要了。</p>

<h2>相关知识</h2>

<ul>
<li>Swing 的Event-Dispatching Thread</li>
</ul>

<h2>练习问题</h2>
<script type='text/javascript'>
$(document).ready(function(){
  if($('code').length>0){
    $('code').parent().addClass('prettyprint linenums');
    prettyPrint();
};
});
</script>
</body>
</html>