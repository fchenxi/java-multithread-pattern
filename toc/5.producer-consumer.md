##概念##

生产者必须将数据安全地交给消费者。虽然只是这样的问题，但当生产者与消费者在不同线程上运行时，两者的处理速度差将是最大的问题。

当消费者要取数据时生产者还没建立出数据，或是生产者建立出数据时消费者的状态还没办法接受数据等等。

Producer-Consumer Pattern 是在生产者与消费者之间加入一个“桥梁参与者”。以这个桥梁参与者缓冲线程之间的处理速度差。

##范例##


- Main.java

操作测试的类


```
public class Main {
    public static void main(String[] args) {
        Table table = new Table(3);     // 建立可以放置3个蛋糕的桌子
        new MakerThread("MakerThread-1", table, 31415).start();
        new MakerThread("MakerThread-2", table, 92653).start();
        new MakerThread("MakerThread-3", table, 58979).start();
        new EaterThread("EaterThread-1", table, 32384).start();
        new EaterThread("EaterThread-2", table, 62643).start();
        new EaterThread("EaterThread-3", table, 38327).start();
    }
}

```

- MakerThread.java

厨师

```
import java.util.Random;

public class MakerThread extends Thread {
    private final Random random;
    private final Table table;
    private static int id = 0; // 蛋糕的流水号（所有厨师相同，同步的）
    public MakerThread(String name, Table table, long seed) {
        super(name);
        this.table = table;
        this.random = new Random(seed);
    }
    public void run() {
        try {
            while (true) {
            	//制作蛋糕-->放在桌上
                Thread.sleep(random.nextInt(1000));
                String cake = "[ Cake No." + nextId() + " by " + getName() + " ]";
                table.put(cake);
            }
        } catch (InterruptedException e) {
        }
    }
    private static synchronized int nextId() {
        return id++;
    }
}

```

- EaterThread.java

客人

```
import java.util.Random;

public class EaterThread extends Thread {
    private final Random random;
    private final Table table;
    public EaterThread(String name, Table table, long seed) {
        super(name);
        this.table = table;
        this.random = new Random(seed);
    }
    public void run() {
        try {
            while (true) {
            //从桌上拿蛋糕-->吃掉
                String cake = table.take();
                Thread.sleep(random.nextInt(1000));
            }
        } catch (InterruptedException e) {
        }
    }
}

```


- Table.java

桌子

```
public class Table {
	//正式环境中推荐使用BlcokingQueue<String> buffer;
    private final String[] buffer;
    private int tail;  // 下一个put的地方
    private int head;  //  下一个take的地方
    private int count; // buffer内的蛋糕数
    public Table(int count) {
        this.buffer = new String[count];
        this.head = 0;
        this.tail = 0;
        this.count = 0;
    }
    // 放置蛋糕
    public synchronized void put(String cake) throws InterruptedException {
        System.out.println(Thread.currentThread().getName() + " puts " + cake);
        //以桌上可以摆的数量上限，减掉现在已经摆的个数,剩下的就是可以摆放蛋糕的空间，得到的值必须大于0
        while (count >= buffer.length) {
            wait();
        }
        buffer[tail] = cake;
        //等价于下面三行，如果超过buffer的长度，就回到0
        //tail++;
        //if(tail >= buffer.length){
        //	tail =0;
        //}

        tail = (tail + 1) % buffer.length;
        count++;
        //因为桌子的状态变化了，所以要执行notifyAll,把wait中的线程全部唤醒
        notifyAll();
    }
    // 获取蛋糕
    public synchronized String take() throws InterruptedException {
    	//蛋糕至少有1个
        while (count <= 0) {
            wait();
        }
        String cake = buffer[head];
        head = (head + 1) % buffer.length;
        count--;
        notifyAll();
        System.out.println(Thread.currentThread().getName() + " takes " + cake);
        return cake;
    }
}

```


##Producer-Consumer Pattern 的所有参与者##

- Data参与者-->String类蛋糕
- Producer（生产者）参与者-->MakerThread
- Consumer（消费者）参与者-->EaterThread
- Channel（通道）参与者-->Table

##适用性##



##缺点##


##知识点##


##练习问题##