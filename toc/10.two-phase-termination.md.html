<!doctype html public '-//W3C//DTD HTML 4.0 Transitional //EN'>
<html>
<head>
<title>10.two-phase-termination</title>
<meta charset='UTF-8' />
<meta name='generator' content='EverEdit' />
<link href='E:\EverEdit\mode\markdown\default.css' rel='stylesheet'></link>
<link href='E:\EverEdit\mode\markdown\prettify.css' rel='stylesheet'></link>
<script type='text/javascript' src='E:\EverEdit\mode\markdown\prettify.js'></script>
<script type='text/javascript' src='E:\EverEdit\mode\markdown\jquery-1.10.2.min.js'></script>
<script type='text/javascript' src='E:\EverEdit\mode\markdown\toc.js'></script>
</head>
<body>
<div id='generated-toc'></div>
<h2>概念</h2>

<p>小朋友总是把玩具洒落一地。晚上到了睡觉的时间时，妈妈会说“快把玩具收拾好，去睡觉吧”。
这时小朋友就停下来不玩了，开始收拾玩具。（这么听话吗？）</p>

<p>先从【作业中】进入【终止处理中】状态，在真正结束掉线程。这就是Two-phase Termination Pattern.</p>

<p>主要考虑的关键因素如下：</p>

<ul>
<li>安全地结束（安全性）</li>
<li>一定会进行终止处理（生命性）</li>
<li>收到终止请求后，要尽快开始终止处理（响应性）</li>
</ul>

<h2>范例程序</h2>

<ul>
<li>Countup Thread.java</li>
</ul>

<p>shutdownRequest方法没有synchronized的必要。因为shutdownRequested标识
是一旦变成true就不会再变成false的latch（门闩），所以就算从多条线程同时调用也无所谓。
因为不会出现同时有线程要求设置为true，又有线程要求设置为false的race condition现象。</p>

<pre><code>public class CountupThread extends Thread {
    // 计数器的值
    private long counter = 0;

    // 已经送出终止请求则为true
    private volatile boolean shutdownRequested = false;

    // 终止请求，下面两个缺一不可，具体原因见知识点
    public void shutdownRequest() {
        shutdownRequested = true;
        //使得线程就算在sleep或是wait的状态下，也能结束掉
        interrupt();
    }

    // 判断终止请求是否已经发出
    public boolean isShutdownRequested() {
        return shutdownRequested;
    }

    // 动作
    public final void run() {
        try {
            while (!isShutdownRequested()) {
                doWork();
            }
        } catch (InterruptedException e) {
        } finally {
            doShutdown();
        }
    }

    // 操作
    private void doWork() throws InterruptedException {
        counter++;
        System.out.println("doWork: counter = " + counter);
        Thread.sleep(500);
    }

    // 终止操作
    private void doShutdown() {
        System.out.println("doShutdown: counter = " + counter);
    }
}
</code></pre>

<ul>
<li>Main.java</li>
</ul>

<p>Thread类的join方法，是用来等待到线程结束用的方法。在指定的线程结束前，不会从join方法中退出。</p>

<pre><code>public class Main {
    public static void main(String[] args) {
        System.out.println("main: BEGIN");
        try {
            // 启动线程
            CountupThread t = new CountupThread();
            t.start();

            // 稍微空出一段时间
            Thread.sleep(10000);

            // 对线程送出终止请求
            System.out.println("main: shutdownRequest");
            t.shutdownRequest();

            System.out.println("main: join");

            // 等待线程结束
            t.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("main: END");
    }
}
</code></pre>

<h2>Two-Phase Termination Pattern的所有参与者</h2>

<ul>
<li>TerminationRequest(送出终止请求的人)参与者：Main类</li>
<li>Terminator（终止的人）参与者 ：CountupThread类</li>
</ul>

<h2>知识点</h2>

<ul>
<li>不可以使用Thread类的stop方法
原因是stop方法会使实例丧失安全性的保障。使用stop方法时，线程会抛出
java.lang.ThreadDeath异常而马上结束。即使该线程现在正在执行临界区间
（例如synchronized方法的中间），也会马上结束。例如下面的例子</li>
</ul>

<pre><code>class Position{
    private int x;
    private int y;
    public synchronized void setXY(int newX,int newY){
        x = newX;
        y = newY;
    }

    ...
}</code></pre>

<p>因为说不定刚好在线程刚进行 x = newX;的指定操作，还没执行到y = newY;的时候，调用到stop方法。
于是，stop方法是不应该使用的。</p>

<ul>
<li>只检查标识是不够周全的 shutdownRequested=true</li>
</ul>

<p>shutdownRequest方法为什么需要调用interrupt方法。也就是说，为什么只把shutdownRequested标识设置为true是不够的呢？</p>

<p>理由很简单，当想要结束掉线程的时候，说不定线程现在正在sleep。如果线程正在sleep，就算将shutdownRequested标识设置为true，
线程也不会开始进行终止处理。或许过了sleep的时候后，就会开始执行终止处理，但这样程序的响应性就变差了。
所以如果使用interrupt方法，就应该把sleep中断掉。</p>

<p>线程或许也可能正在wait。如果线程正在wait，就算将shutdownRequested标识设置为true了，线程也不会退出等待区。
所以我们必须使用interrupt方法，要求线程“不要wait”了。</p>

<ul>
<li>只测试中断状态也是不够的 interrupt()</li>
</ul>

<h2>练习问题</h2>
<script type='text/javascript'>
$(document).ready(function(){
  if($('code').length>0){
    $('code').parent().addClass('prettyprint linenums');
    prettyPrint();
};
});
</script>
</body>
</html>