<!doctype html public '-//W3C//DTD HTML 4.0 Transitional //EN'>
<html>
<head>
<title>7.thread-per-message</title>
<meta charset='UTF-8' />
<meta name='generator' content='EverEdit' />
<link href='E:\EverEdit\mode\markdown\default.css' rel='stylesheet'></link>
<link href='E:\EverEdit\mode\markdown\prettify.css' rel='stylesheet'></link>
<script type='text/javascript' src='E:\EverEdit\mode\markdown\prettify.js'></script>
<script type='text/javascript' src='E:\EverEdit\mode\markdown\jquery-1.10.2.min.js'></script>
<script type='text/javascript' src='E:\EverEdit\mode\markdown\toc.js'></script>
</head>
<body>
<div id='generated-toc'></div>
<h2>概念</h2>

<p>上司把文件交给下属，指示“能帮我传真这份文件吗？”妻子对先生说“老公，帮忙倒一下垃圾喔”。
一个人将工作拜托给别人去做，是很常见的事情。拜托别人“这个工作交给你了”泥猴，就回来继续做自己的事情。</p>

<p>使用Thread-Per-Message Pattern时，“委托消息的一端”与“执行消息的一端”会是不同的线程。
也就像是委托消息的线程，对执行消息的线程说“这个工作交给你了”</p>

<h2>范例</h2>

<ul>
<li>Host.java</li>
</ul>

<pre><code>public class Host {
    private final Helper helper = new Helper();
    //在匿名内部类中，用到方法的参数或局部变量时，必须将变量声明称final。如果没有，会出现编译错误。
    public void request(final int count, final char c) {
        System.out.println("    request(" + count + ", " + c + ") BEGIN");
        new Thread() {
            public void run() {
                helper.handle(count, c);
            }
        }.start();
        System.out.println("    request(" + count + ", " + c + ") END");
    }
}
</code></pre>

<ul>
<li>Helper.java</li>
</ul>

<pre><code>
public class Helper {
    public void handle(int count, char c) {
        System.out.println("        handle(" + count + ", " + c + ") BEGIN");
        for (int i = 0; i &lt; count; i++) {
            slowly();
            System.out.print(c);
        }
        System.out.println("");
        System.out.println("        handle(" + count + ", " + c + ") END");
    }
    private void slowly() {
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
        }
    }
}
</code></pre>

<ul>
<li>Main.java</li>
</ul>

<pre><code>public class Main {
    public static void main(String[] args) {
        System.out.println("main BEGIN");
        Host host = new Host();
        host.request(10, 'A');
        host.request(20, 'B');
        host.request(30, 'C');
        System.out.println("main END");
    }
}
</code></pre>

<h2>Thread-Per-Message Pattern参与者</h2>

<ul>
<li>Client（委托人）参与者：Main类</li>
<li>Host参与者：Host类</li>
<li>Helper（帮助者）参与者：Helper类</li>
</ul>

<p>Client&#8211;调用&#8211;>Host&#8211;使用&#8211;>Helper</p>

<h2>扩展思考</h2>

<ul>
<li>提升响应性，降低延误时间</li>
</ul>

<p>为了降低启动线程所需的时间，可使用Worker Pattern</p>

<ul>
<li>适当在操作顺序无所谓时使用</li>
</ul>

<p>handle的顺序并不一定是调用request方法的顺序。如果对操作顺序有要求，不适合使用Thread-Per-Message Pattern</p>

<ul>
<li>不需要返回值的时候</li>
</ul>

<p>例如通知事件的发生等等。
如果需要处理结果时，可使用Future Pattern</p>

<ul>
<li>应用在服务器的制作</li>
</ul>

<p>为了使服务器可以处理多数的请求，可以使用Thread-Per-Message Pattern。
客户端送达的请求，由主线程来接受。而实际处理该请求，则交给其他线程负责，服务器的主线程回到继续等待其他客户端请求的状态。</p>

<ul>
<li>调用方法+ 启动线程->传递消息</li>
</ul>

<p>通常调用处普通方法时，会执行完方法里的所有操作，控制权才会回来。Thread-Per-Message Pattern里，因为request也是普通方法，所以也是执行完request方法的内容，
控制权才回来。但请思考“request方法又进行真正想要做的操作（显示字符串）了吗？”并不是从request方法回来，就表示字符串显示完了。request是期待的操作开始处理的
出发其（Trigger），但不会等待执行结束。</p>

<h2>练习问题</h2>

<ul>
<li>不使用Thread-Per-Message Pattern 的版本</li>
</ul>

<pre><code>public class Host{

    private final Helper helper = new Helper();
    public void request(final int count ,final char c){
        System.out.println("      request("+ count+", "+c+") BEGIN");
        helper.handle(count,c);
        System.out.println("      request("+ count+", "+c+") END");

    }

}</code></pre>
<script type='text/javascript'>
$(document).ready(function(){
  if($('code').length>0){
    $('code').parent().addClass('prettyprint linenums');
    prettyPrint();
};
});
</script>
</body>
</html>