<!doctype html public '-//W3C//DTD HTML 4.0 Transitional //EN'>
<html>
<head>
<title>7.thread-per-message</title>
<meta charset='UTF-8' />
<meta name='generator' content='EverEdit' />
<link href='E:\EverEdit\mode\markdown\default.css' rel='stylesheet'></link>
<link href='E:\EverEdit\mode\markdown\prettify.css' rel='stylesheet'></link>
<script type='text/javascript' src='E:\EverEdit\mode\markdown\prettify.js'></script>
<script type='text/javascript' src='E:\EverEdit\mode\markdown\jquery-1.10.2.min.js'></script>
<script type='text/javascript' src='E:\EverEdit\mode\markdown\toc.js'></script>
</head>
<body>
<div id='generated-toc'></div>
<h2>概念</h2>

<p>上司把文件交给下属，指示“能帮我传真这份文件吗？”妻子对先生说“老公，帮忙倒一下垃圾喔”。
一个人将工作拜托给别人去做，是很常见的事情。拜托别人“这个工作交给你了”泥猴，就回来继续做自己的事情。</p>

<p>使用Thread-Per-Message Pattern时，“委托消息的一端”与“执行消息的一端”会是不同的线程。
也就像是委托消息的线程，对执行消息的线程说“这个工作交给你了”</p>

<h2>范例</h2>

<ul>
<li>Host.java</li>
</ul>

<pre><code>public class Host {
    private final Helper helper = new Helper();
    //在匿名内部类中，用到方法的参数或局部变量时，必须将变量声明称final。如果没有，会出现编译错误。
    public void request(final int count, final char c) {
        System.out.println("    request(" + count + ", " + c + ") BEGIN");
        new Thread() {
            public void run() {
                helper.handle(count, c);
            }
        }.start();
        System.out.println("    request(" + count + ", " + c + ") END");
    }
}
</code></pre>

<ul>
<li>Helper.java</li>
</ul>

<pre><code>
public class Helper {
    public void handle(int count, char c) {
        System.out.println("        handle(" + count + ", " + c + ") BEGIN");
        for (int i = 0; i &lt; count; i++) {
            slowly();
            System.out.print(c);
        }
        System.out.println("");
        System.out.println("        handle(" + count + ", " + c + ") END");
    }
    private void slowly() {
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
        }
    }
}
</code></pre>

<ul>
<li>Main.java</li>
</ul>

<pre><code>public class Main {
    public static void main(String[] args) {
        System.out.println("main BEGIN");
        Host host = new Host();
        host.request(10, 'A');
        host.request(20, 'B');
        host.request(30, 'C');
        System.out.println("main END");
    }
}
</code></pre>

<h2>Thread-Per-Message Pattern参与者</h2>

<ul>
<li>Client（委托人）参与者：Main类</li>
<li>Host参与者：Host类</li>
<li>Helper（帮助者）参与者：Helper类</li>
</ul>

<p>Client&#8211;调用&#8211;>Host&#8211;使用&#8211;>Helper</p>

<h2>扩展思考</h2>

<ul>
<li>提升响应性，降低延误时间</li>
</ul>

<p>为了降低启动线程所需的时间，可使用Worker Pattern</p>

<ul>
<li>适当在操作顺序无所谓时使用</li>
</ul>

<p>handle的顺序并不一定是调用request方法的顺序。如果对操作顺序有要求，不适合使用Thread-Per-Message Pattern</p>

<ul>
<li>不需要返回值的时候</li>
</ul>

<p>例如通知事件的发生等等。
如果需要处理结果时，可使用Future Pattern</p>

<ul>
<li>应用在服务器的制作</li>
</ul>

<p>为了使服务器可以处理多数的请求，可以使用Thread-Per-Message Pattern。
客户端送达的请求，由主线程来接受。而实际处理该请求，则交给其他线程负责，服务器的主线程回到继续等待其他客户端请求的状态。</p>

<ul>
<li>调用方法+ 启动线程->传递消息</li>
</ul>

<p>通常调用处普通方法时，会执行完方法里的所有操作，控制权才会回来。Thread-Per-Message Pattern里，因为request也是普通方法，所以也是执行完request方法的内容，
控制权才回来。但请思考“request方法又进行真正想要做的操作（显示字符串）了吗？”并不是从request方法回来，就表示字符串显示完了。request是期待的操作开始处理的
出发其（Trigger），但不会等待执行结束。</p>

<h2>练习问题</h2>

<ul>
<li>不使用Thread-Per-Message Pattern 的版本</li>
</ul>

<pre><code>public class Host{

    private final Helper helper = new Helper();
    public void request(final int count ,final char c){
        System.out.println("      request("+ count+", "+c+") BEGIN");
        helper.handle(count,c);
        System.out.println("      request("+ count+", "+c+") END");

    }

}</code></pre>

<ul>
<li>修改Host类，为不使用匿名内部类的版本</li>
</ul>

<pre><code>//方法一：将HelperThread类声明为Top Level类

public class Host{
    private Helper helper =new Helepr();
    public void request(int count ,char c){
        SYstem.out.println("   request(" +count+ "," +c+") BEGIN");
        new HelperThread(helper,count,c).start();
        SYstem.out.println("   request(" +count+ "," +c+") END");
    }
}

public class HelperThread extends Thread{

    private final Helper helper;
    private final int count;
    private final char c;
    public HelperThread(Helper helper,int count,char c){
        this.helper = helper;
        this.count = count;
        this.c = c;
    }

    public void run(){
        helper.handle(count ,c);
    }
}

</code></pre>

<pre><code>//方法二：将HelperThread声明为非匿名的内部类
public class Host{
    private Helper helper =new Helepr();
    public void request(int count ,char c){
        System.out.println("   request(" +count+ "," +c+") BEGIN");
        new HelperThread(helper,count,c).start();
        System.out.println("   request(" +count+ "," +c+") END");
    }


    //Inner class
    private class Helper{
        public void handle(int count,char c){
            System.out.println("   request(" +count+ "," +c+") BEGIN");
            for(int i=0;i&lt;count;i++){
                slowly();
                System.out.println(c);
            }

            System.out.println("");
            System.out.println("   request(" +count+ "," +c+") END");
        }
        private void slowly(){
            try{
                Thread.sleep(100);
            }catch(InterruptedException e){

            }
        }

    }

    //Inner class
    private class HelperThread extends Thread{
        private final Helper helper;
        private final int count;
        private final char c;

        public HelperThread(Helper helper,int count,char c){
            this.helper = helper;
            this.count = count;
            this.c = c;
        }

        public void run(){
            helper.handle(count,c);
        }
    }

}


</code></pre>

<ul>
<li>单击右侧的[Execute]按钮时，Swing的framework会去调用actionPerformed方法
，在actionPerformed方法里，会调用Service类的service方法。
因为service方法很花时间，这么一来要从actionPerformed方法退出，得等上一些时间。
这会使按钮的反应、应用程序对用户的反应都慢下来。
改写Service类，提高这个类的响应性</li>
</ul>

<p>方法1:使用Thread-Per-Message模式，
连续按下按键，每次按下都会执行doService的Service类</p>

<pre><code>public class Main {
    public static void main(String[] args) {
        new MyFrame();
    }
}
</code></pre>

<pre><code>public class Service {
    public static void service() {
        new Thread() {
            public void run() {
                doService();
            }
        }.start();
    }
    private static void doService() {
        System.out.print("service");
        for (int i = 0; i &lt; 50; i++) {
            System.out.print(".");
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
            }
        }
        System.out.println("done.");
    }
}
</code></pre>

<pre><code>import java.io.IOException;
import java.awt.FlowLayout;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JButton;

public class MyFrame extends JFrame implements ActionListener {
    public MyFrame() {
        super("MyFrame");
        getContentPane().setLayout(new FlowLayout());
        getContentPane().add(new JLabel("Thread-Per-Message Sample"));
        JButton button = new JButton("Execute");
        getContentPane().add(button);
        button.addActionListener(this);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        pack();
        setVisible(true);
    }
    public void actionPerformed(ActionEvent e) {
        Service.service();
    }
}
</code></pre>

<p>方法2：使用Thread-Per-Message 模式与Single Threaded Execution模式</p>

<pre><code>public class Service {
    public static void service() {
        new Thread() {
            public void run() {
                doService();
            }
        }.start();
    }
    private static synchronized void doService() {
        System.out.print("service");
        for (int i = 0; i &lt; 50; i++) {
            System.out.print(".");
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
            }
        }
        System.out.println("done.");
    }
}
</code></pre>

<p>方法3：使用Thread-Per-Message 模式与Balking模式</p>

<pre><code>public class Service {
    private static volatile boolean working = false;
    public static synchronized void service() {
        System.out.print("service");
        if (working) {
            System.out.println(" is balked.");
            return;
        }
        working = true;
        new Thread() {
            public void run() {
                doService();
            }
        }.start();
    }
    private static void doService() {
        try {
            for (int i = 0; i &lt; 50; i++) {
                System.out.print(".");
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                }
            }
            System.out.println("done.");
        } finally {
            working = false;
        }
    }
}
</code></pre>

<p>方法4：连续按键多次时就将执行中的处理予以取消</p>

<pre><code>public class Service {
    private static Thread worker = null;
    public static synchronized void service() {
        // 如果有执行中的处理，就是用interrupt取消
        if (worker != null &amp;&amp; worker.isAlive()) {
            worker.interrupt();
            try {
                worker.join();
            } catch (InterruptedException e) {
            }
            worker = null;
        }
        System.out.print("service");
        worker = new Thread() {
            public void run() {
                doService();
            }
        };
        worker.start();
    }
    private static void doService() {
        try {
            for (int i = 0; i &lt; 50; i++) {
                System.out.print(".");
                Thread.sleep(100);
            }
            System.out.println("done.");
        } catch (InterruptedException e) {
            System.out.println("cancelled.");
        }
    }
}
</code></pre>
<script type='text/javascript'>
$(document).ready(function(){
  if($('code').length>0){
    $('code').parent().addClass('prettyprint linenums');
    prettyPrint();
};
});
</script>
</body>
</html>